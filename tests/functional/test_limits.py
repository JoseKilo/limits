import random
from base64 import b64decode

from flask import json, url_for

from limits.api.models import Card


def test_home(client):
    """
    The root path returns a home page with some instructions
    """
    url = url_for('api.home')

    response = client.get(url)

    assert response.status_code == 200
    assert 'flask run' in response.data.decode('UTF-8')


def test_generate_token(client):
    """
    The client can fetch a token generated by the server
    """
    url = url_for('api.generate_token')

    response = client.post(url, data={})

    assert response.status_code == 200
    data = json.loads(response.data)
    assert set(data.keys()) == {'client_token'}
    token = data['client_token']
    decoded = json.loads(b64decode(token))
    assert decoded['version'] == 2


def random_amount(maximum, *, minimum=0):
    """
    Generate a random amount of money

    Using random amounts we avoid 'duplicate' errors. We could disable that
    check in the Sandbox settings, but then we couldn't test that specific
    condition.
    """
    return str(round(random.uniform(minimum, maximum), 2))


def test_load_card(client):
    """
    The client can load money into a card

    Note: we use specific 'nonce' and 'amount' test values to trigger different
    responses from the external API
    """
    nonce, amount = 'fake-valid-visa-nonce', random_amount(1999.99)
    card_id = Card.query.one().id
    url = url_for('api.load_card', card_id=card_id)

    response = client.post(url, data={'nonce': nonce, 'amount': amount})

    assert response.status_code == 200
    data = json.loads(response.data)
    assert data == {'status': 'ok', 'errors': []}


def test_load_json(client):
    """
    We can use the endpoints with an 'application/json' content type
    """
    nonce, amount = 'fake-valid-visa-nonce', random_amount(1999.99)
    card_id = Card.query.one().id
    url = url_for('api.load_card', card_id=card_id)

    response = client.post(url, content_type='application/json',
                           data=json.dumps({'nonce': nonce, 'amount': amount}))

    assert response.status_code == 200
    data = json.loads(response.data)
    assert data == {'status': 'ok', 'errors': []}


def test_load_payment_rejected(client):
    """
    If the payment is declined, we get an error

    Note: we use 'amount' value to trigger a 'Processor Declined' response
    """
    nonce, amount = 'fake-valid-nonce', random_amount(2000.99, minimum=2000.01)
    card_id = Card.query.one().id
    url = url_for('api.load_card', card_id=card_id)

    response = client.post(url, data={'nonce': nonce, 'amount': amount})

    assert response.status_code == 400
    data = json.loads(response.data)
    assert data == {'status': 'error', 'errors': [{'code': '2000',
                                                   'message': 'Do Not Honor'}]}


def test_load_exceed_limits(client):
    """
    If the payment exceeds any compliance limit, we get an error
    """
    nonce, amount = 'fake-valid-nonce', random_amount(6000.00, minimum=5002.00)
    card_id = Card.query.one().id
    url = url_for('api.load_card', card_id=card_id)

    response = client.post(url, data={'nonce': nonce, 'amount': amount})

    assert response.status_code == 400
    data = json.loads(response.data)
    assert data == {'status': 'error', 'errors': [
        {'code': 'compliance-1 day', 'message':
         'ComplianceError: 0 + {} > 5000 (1 day)'.format(amount)},
    ]}
